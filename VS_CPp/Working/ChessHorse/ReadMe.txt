Задача: Путь коня по шахматной доске.

Ещё одна классическая задача. Нужно обойти конём все поля шахматной доски,
начав с некоторого выбранного поля. Приведённая программа - консольная,
но она иллюстрирует свои действия печатью того, какие варианты сейчас
перебираются (на это и уходит 99% времени работы, лень было писать прямо
в видеопамять). Константа N в программе задаёт размер доски, 
сейчас там значение 5
при значении N=8, думаю, будет считаться довольно долго
(метод простейший - полный рекурсивный перебор возможных путей).
Нумерация полей - слева и сверху, с нуля. Путь из левого верхнего угла для
доски 5x5 будет успешно найден.

P.S. Кстати, не так уж долго это работает, вот листинги некоторых результатов
с вычислением требуемого числа шагов.
На доске 4*4 или менее решения не существует.

Для доски 5*5:

01 08 19 14 25
18 13 02 09 06
03 20 07 24 15
12 17 22 05 10
21 04 11 16 23

Res=1,Steps=614838

Для доски 6*6:

01 24 27 12 09 36
22 11 02 25 28 13
03 26 23 10 35 08
18 21 04 31 14 29
05 32 19 16 07 34
20 17 06 33 30 15

Res=1,Steps=82995890

Для доски 7*7:

01 20 29 42 45 38 31
28 43 02 19 30 41 46
03 18 21 44 39 32 37
22 27 04 17 36 47 40
05 08 11 26 33 16 35
12 23 06 09 14 25 48
07 10 13 24 49 34 15

Res=1,Steps=84376540

Для доски 8*8:

36 31 48 57 38 41 50 59
47 56 37 30 49 58 39 42
32 35 54 45 40 29 60 51
55 46 33 26 53 62 43 28
34 25 06 13 44 27 52 61
07 14 17 24 05 12 63 20
16 23 02 09 18 21 04 11
01 08 15 22 03 10 19 64

Res=1,Steps=174326079

В этих тестах использовалась чуть изменённая версия программы
(убрана промежуточная печать и добавлен общий счётчик числа шагов).
Кроме того, массив xy незачем делать локальным.
Для доски 8x8 с начального поля (0,0) решение в разумное время вообще не нашлось,
а вот с левого нижнего поля доски int n=Path (N-1,0); получилось быстро.

Следует понимать, что как и любое рекурсивное решение,
программа активно пользуется стеком и при "плохой"
компиляции может привести к переполнению стека.


 /* ---------------------------------------------------------------
Рекурсивная программа
Наиболее известное решение для задачи обхода конем — рекурсивное. 
При этом структура функции, выполняющей перебор, имеет следующий вид:

int find_path( int cur_x, int cur_y, int move_num )
{
desk_state[cur_x][cur_y] = move_num ; // Запомнить ход.
if( move_num > max_moves ) return 1 ; // Проверить завершение обхода.
// Проверить каждый возможный ход из текущей клетки.
for( int i = 0 ; i < 8 ; i++ )
{
int next_x = cur_x + possible_moves[i][0] ; // Определить следующее поле.
int next_y = cur_y + possible_moves[i][1] ;
if( move_possible( next_x, next_y )
&& find_path( next_x, next_y, move_num+1 )) return 1 ;
}
// Возврат.
desk_state[cur_x][cur_y] = 0 ;
back_ret++ ;
return 0 ;
}
---------------------------------------------------------------*/


/* ---------------------------------------------------------------

А вот еще одно решение... Но есть ошибка.... Требуется исправление.

static int dx[8] = { 1,2,2,1,-1,-2,-2,-1 };
static int dy[8] = { 2,1,-1,-2,-2,-1,1,2 };
int a[11][11];
int x, y, n;

int write()
{
int k, e;
system("cls");
for (k = 1; k <=n; k++)
{
for (e = 1; e <=n; e++)
printf("%4i", a[k][e]);
cout << "\n";
}
return 0;
}

int rec(int i, int x, int y)
{
int j;

if (a[x][y] == 0)
{
a[x][y] = ++i;
if (i == n * n) write();
else for (j = 1; j < 9; j++) {
rec(i + 1, x + dx[j], y + dy[j]);
a[x][y] = 0;
}
}
//
//if (x<0 || x>n - 1 || y<0 || y>n - 1) return 0;
return 0;
}

int main()
{
setlocale(LC_ALL, "rus");
system("color F0");
cout << "\n\n\tПрактична робота. Тема: ChessHorse \n\n\t";

n = 5;
for (x = 0; x < 11; x++)
for (y = 0; y < 11; y++) a[x][y] = -1;
for (x = 1; x <9; x++)
for (y = 1; y <9; y++) a[x][y] = 0;
rec(1, 1, 1);
cout << endl << endl << "\t";
system("pause");
return 0;
}

---------------------------------------------------------------*/
